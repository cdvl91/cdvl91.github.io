<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="CDVL91 Comité Départemental de Vol Libre de l'Essonne Parapente, Deltaplane, Kite, Cerf-Volant, Boomerang">

    <link href="/assets/style.css" rel="stylesheet">
    <link href="/assets/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/awesome.all.min.css" rel="stylesheet">

    <title>CDVL91 &mdash; Comité Départemental de Vol Libre de l'Essonne</title>
  </head>
  <body>


<nav class="navbar navbar-expand-lg navbar-dark bg-ffvl-col">
  <div class="container-fluid">
	<a class="navbar-brand" href="http://cdvl91.fr">CDVL91</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
	  <span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="navbarSupportedContent">
	  <ul class="navbar-nav me-auto mb-2 mb-lg-0">
		<li class="nav-item">
		  <a class="nav-link " href="/pratiquer.html">Pratiquer</a>
		</li>
		<li class="nav-item">
		  <a class="nav-link " href="/a-propos.html">À propos</a>
		</li>
		<li class="nav-item">
		  <a class="nav-link " href="/clubs.html">Clubs</a>
		</li>
		<li class="nav-item dropdown">
		  <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
			Articles
		  </a>
		  <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
			<li><a class="dropdown-item" href="/evenements">Évènements</a></li>
			<li><a class="dropdown-item" href="/sorties">Sorties</a></li>
			<li><a class="dropdown-item" href="/formations">Formations</a></li>
			<li><a class="dropdown-item" href="/jeunesse">Jeunesse</a></li>
			<li><a class="dropdown-item" href="/action_feminine">Action féminine</a></li>
		  </ul>
		</li>
	  </ul>
	  <form name="search" class="d-flex" action="https://duckduckgo.com/" method="get">
		<input class="form-control me-2" type="search" name="q" placeholder="Rechercher" aria-label="Rechercher">
		<button class="btn btn-outline-success" type="submit" >Rechercher</button>
	  </form>
	</div>
  </div>
</nav>

<div class="container pt-3">
  

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="d-none">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <h3 class="staticrypt-title">Page protégée</h3>
                <p>Entrez le mot de passe pour accéder au fonctionalités d'administration...</p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group mb-3 staticrypt-password-container">
                    <input
                        id="staticrypt-password" class="form-control"
                        type="password"
                        name="password"
                        placeholder="mot de passe"
                        autofocus
                    />
                    <button class="btn btn-outline-secondary" type="button" id="staticrypt-btn-password-visibility">
                        Voir en clair
                    </button>
                </div>

                <div class="mb-3 form-check">
                    <label id="staticrypt-remember-label" class="form-check-label staticrypt-remember" for="staticrypt-remember">
                        Se souvenir du mot de passe
                    </label>
                    <input id="staticrypt-remember" class="form-check-input" type="checkbox" name="remember" />
                </div>

                <input type="submit" class="btn btn-primary staticrypt-decrypt-button" value="Envoyer" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Mot de passe incorrect",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8572d07a1c19ddeb9a97a2e88659b7a8f17bb46b4ca79bd2ff305abc24dae290f5ac5ef427af78ed9d6a57df799b427d65b02cf459ab4a5a5e0bb802c2ef73d15ff7462333a3a00e2d5cb539856b5afe91e6d00691cedd7dd9a5bd29af63e01d356690e66f3c8cd41e863f4f6003dcec602d232ee087403d5696fd55237938f2e3800d4d5c1bc531d7ef7c87f424b2d806e3469faeebcbe4e79de5b235bfdd6d1b4eb6e532826c68752d951e1a2603ba38e95aa2ea5e387da853e16e38243f4c649ebfdd37067d9e2f6848069f373b010533adda976aded6de3dfd3c2d76c92902f66a58774c89b41ed3a52ad36bacb869e4abe080df245760b5dc6a20e4e85b025fe4c583c9b32ad2a17772d580b09f7c2dde15b6666960201874a5fa4452a7c2beb773f81f2e5d6726b9c61c20df77dd86892dcce1c456f40562cfdb639c85575aefd1627be3ba6c2eab608cf872eaaac8c3ebb8de01b95065bdd4d4dc5617bc8cfbfb6b23cc959ab20e46ae8e54c1bc29a3bec8330877591f4a201393a02be961d824ceb85eabffbdd4722a3219bab801c68f1483b33e862c0c1cc037c478340e0deb3a2bf0be983b05a72286c9f64b15f8c1764d2f3be84d26ba8679b807a31eef94750acfeea5b37e5187f3b1dc6e31e568d69ad1546f8d925b2cb69998e0806a1c42455a75ea19e2033f99d3f780ae56e3341b7385eb5a2370e68bc2d891f6bff43fee21bf1b30aafe94b1f3b635154d27e305fa8ae8f8e5d58c441769b9411114bd773052eeb4a4a4792415e0eaed94dc83b3280e0c6950a0ea330e33dc2f9da230a38d30fba9c06878898ab936c87184a649fae35f4163e797c37038995d6a52a3580ada3df7130cfcdf0f98ad0c6f9d49deb66e92840bc700ed42b8f68eaee4b67ee7b3767e25cdec11c073772f6a5aa351fbfe373bd144b72274698c90fff04089ac13cc60bb351ade6ddbb295c9b48103a318512d1a9a4d6fb6c6562ae060e1a9a9d95447062cd5f3c204da617cb7c2a03d68431131e65dfc4ff5b9cb7f1726ae841c43eb4a60e67cac30ad5f1fff253498d32e8e7cb4fcef1daf109b4f7e5ee5f8a9f136052431a784f94033ee98b9e7389fb63738b328a876ce8b79726b068151f94002025ab7b404bf0affeb1c75d71546ae6d71270bbf19741444ee25e154ba8f7a237022a6bbc98387c0c4a92fbd8b83abb2d06f93c6c73651676c75c5e24335ce4e1f4e7c063e86c8a16d059e16627ef1f8742ed56d1a1b5b05c0c40f981b141fab76f2b0d0a88dc44bc624fd8132c2e652d1b7442e1784fe2178de09db80d7a50a685ab8f62bd449e9678506ada24873ef36f82b9025947049cf9be75fa6f26df57b8ce8c0755791cac4414499d224de7a62005a4b7f44f2f783e42f3161fd84950a44a5f70f5df636edb61b27847a0963ef8fbc0b9bd32f429a8b8db98a4b27c9f90fe9772b65878350098a007bf6978bfd1ef750063349befd50586292e776a5de4aea8e00f3ab4a81decec7d9bf8631476df0da7a6e06eed1af5affe7c39da9c04138e8323f46f2b07867a2839212bff423543b2628c978d735d1c063a1f26cb870301bb64039dcc66299eab11ba7f21148bba2c31583e62319d0a357a5ec81a33b808277758d37fdbbdcf083e62df50307cbcb045396d272e9ac58be0e12ef8ed6e5029169d85b4c13a6d44265adb87da6747be6893f18945501263f3b28b22a9179c802d7120cc39e7576577533d20606d6b1467d2838b3b07f44ee624690cfd2bbd3c5909641cb0d9d6676ddd4f26c897f72915400e5282e0ed1deaea01ec93268b18a074c3fd28291000ea88600e1a0d567408170d911014753b429b26fd9658faa0939dfb64ebb5a555cd8a9223aa3e7d7d6e8a5945d36d1b1192a2b31f507f88285d947e57635e68ee845f380c725a05c98f46236ab7f08da83aaa89c6f30027e44a308290d84bfeccf615fb940ed5fcd64486a24d8c546b6f213af46275a87a8ca9b60ecb3e8a2752f62ace57136ed62eedb727c898baec413502f6f493c263a70ee2449c0ed6290d98813e4e70e2caa073a1d5633ac137fa6d3bd6efe6758a266dfcfd9593ffef43894cf8a9e962bfdb38d5f162ca72334ecf8b6f50aebafb717dd1c285ca77d6e92a184147c5525a6184b1efa2c9addd12156cd07794a4c1298c13776705792249aa228559ca0991f14a23d0011012845d287cdc8e0c0be840e1e05d85d35272ee9c5b96b4c3841eb8c0baf90c9e4cee1736113bb70e485597002f3b16010c3a909e414cec8a02fd0cc8a96ecc0eebdddca842f593b51a3ae92792bb61f5ccf3d16f8514ba607754e69c862018197efb95b3b55b97f3d38abf6b2e8bbe5f1cd34b4a63efe2fdc6da8adbbbedf5b355fca3c6953d7026218a5e81501211b90b405f4b8036351991f05328a5ab50d808fab9d24804fd8a065a482840e4470d3f75185f7a1d0138a065d79550da73618dffc07b6f30bb2aca7d734d9c1cdd55c50638c0388f78920ee79f99cd914d9735e83f1d392fdca8a9263180571844820e2bdd1e9635d5c50f7cead45a2a04cafbe852832d22c56526f3a5623c127e4214d6d3d10a52391227495a9dc49e1c408e757b49e3e38447f727096af10cd92997479f255246e94adcf5716c18fbee3c414aa10e1e56ca3d61579f3ae7ee04ea53067a6f93b2f119f426e7ebbcf9a40a2ab3bbbb5fc787ff8b1dbf0fb10b01418200678a44b52cf2106af2741a3dfadd298ac564c8e68fe46f02fa3916e2abe84c8df46aee60cc83dd84d618c9fb72bd2bc29668774c271b68130de5de9ccd5955f61b4e6e67e0d5ebea226252c21f074ffd3a8f9218e5fc0b6124cc3403de29355d8415dcc691621cd80a06dc794bf99154c837cb92da3f086fe0a617a62d7987116370d3f21be36021a34fa80707c6980293a8c48b9291d8e51bb47c967cf28a01da0c73c6d93a3fd88fbd137f94173c488e11883480ec4fc1a98da59e2f306f8a933326721a78591b71c164e46563c3539ece3ecaca1f22142d5ad3584eb093ea2897d4aaaef898e151d1327282e8b3cc045ee351dd3cd7009ff40906e7d5f9baeda7a887734b6585caf23500f2185ac6f5ef8b972a445e5fe656aeca78d3c1f06de7939ce8ba6b477ec1bd1c80c73a05e68d0e31a2cac8b486876b9f9079ead08b64811cc18438f9a3aadb115aa36e178a4919fb69426504bbfae47be702b2def32c4683dee85034e977dc6b770e9b3686aa6093d02ccade358f65196e3e2ecc7ff574169010d090b6e335b802bcbb003822acf20e4c216abf5b6c43b29a1eb60ea9a70c553f8fa62f5b959864acfc7db7e7c3ac195f5ab9b0de7c662e28bb931d5cade1adde69f334ff6589a642add8fa06a9b25ae018775e9493c599f27bb9ced84a288933abe2edff6f04376475d4544a33ff00f820a1c8f391cf417d6eade8e3053b1c6f7630f10502af002fc9e78ee3cebfaa622d818fe6bbb1e464186096b682f2df08eb3787728f4a4b28ca18daccb795de72ebbb1d53ea99ad71847d692598d6950cd2237d0406463c3f69a87dd0764fe5fa7125e098daef8060e4e30ae5a7b69f291020646d5777d1e1f09c2bfdf02a9dc60c5f9c1ba5406179bb217f39595c60bbacc37f1a7eb7b404ca1115f78db6d04f235d6dc07d8908a0b079ade8667a2077d7f26ca2aa15e0eea40bf84a1be77f4642a48f188b843e84597ca980769fe1687f59cde8639b76b9c8827fc8500c431ec8f18ce6844251a2b58a280f4b2753d3b93b80054aece605425061f0cf07f063ce593bfb00fcf231cf0d85bf5e48eae10754ae11bc4af758b7e331583ade4ba2a9e5c191df6a908fe693227ba40110f8668468cdf9e9e309e790866226f44b1aad0fee871fb502bd8faa7e4b6b2b4ef2ee725af00e02c7dd499018780788a991379942973e8b86a745f113a3509d7e5940f5a038c443786c8a15e69c34b4eb7e1ed0285c3b805e3e4518ab107feb55878a5aef8dd25984cf2f10dfc299348a7a147df95f3bf1f3ffb36c73154aacbbd7bea6796bec8689de7facef6772f5d80ec86689c63d8d750cb9057f648960b8eabf5e5946479be843f8d4a562ef6aa494b492b5e05bc817b82215b4293c357921f1676f6b4cfb652de18e0810decc466fcffd0a712b5655759ef67d7b3c763fb8871769664c0ec0e9858d38ec7f36bc410bebcdec80e149f10c87b889caa31e8a63f2bb3addc68bf39a3a1f6da268906091cb9ef9dfcf17365fa7b082e5605814376fc73e3b0952d6579ad40b78f16f2535b8bb66c79816ba57d0ae671925faa1173dd7ba0ca84d47ec57f95e985277525dca487d738942f14c4514b374666b62e6938fb01fa02410849d059a15e62f96f0d0a3914f2efd3c506f1cbe3e346c99efeab29dc18da9efa70480b49aaca49dd2a013e83199eb23cd8f634bdd14ef5d8a04a2c2663d7c9aacff51249dfa06319b2294eb0f395f7fc24f11c0596ca3107d408b5cf6136bbe547c2a010b18dcf1faf7724caf960c95ed8a01699ba547823b47c5382606a060a5b70145de79b7308ff8f20cafaa45566a82d71f7cd4f108d21023bb3cc325c056c769323b6329575b2bcbbf1d12cad438cce7026555ef4dd80a14af5fe2c1d4da1d6a68c9fb122111cc5965c65643751ef071dc21307f0870cfa45f0c9b4d7fbabe39496872bcf3d93a29b0e64a03b8c134734e3620b2f09bb6a732ff11a6a95a8866b2845e38ceb9bd749ef226127e278012eb5a9061453389e1c5ce23469199527764c99622e2b6b51131fed40398dab83876e785c81115a9988ed2fddf5c4acaae8091600ed1bbdf54379f365f8eaa3498225f9089a3e803dbcf11b1dca211ec218782b78fb82f728b3a6954c2849087c89f9f50b40dee35cf4a0c437a603421041aa6a491c61347b5df326b27b506a72221fe0ad3169b539cfd7016d07da73216553c89219463cce46a8c22550257efceb9ec2c39412b45b53e5f639ca41c48a59401df279ffd5789acc828fb8094ceea7d319ba7928812c82bd91d6ff05d6c73841133e0d66f56fc9347b463481fd1537489455bf609374fb5c273c55deaf4db3226ef27c585e172ae2212a677bab3e2d08e979a9c3d6cbddee3dde9180235676bd4bbdd5a34d26a1fe5cdb0450de18962024f683deeec9baa23b93b2af9f864a3f306470c271ac114098d3a30a033a47637fa7f9b85a7fa20bb21b9a9829a92906105daccd8c8aad3d1e67d7f570ea79267993d6f46e6ebf08cf07b428b6c32f9d79a7457410c0aa206c41fbd5862dc4becedad56dfcbb2e81ebf44758384671f7ae700e4eb9a04d404fff2d2a1351f8e3f9185883b9df102853b390e95c78b61cff7941ab847f748038f8bc26d72bc5b749553468b2b5b5c5a5f31ca8b7b615903635da54069d8b2289cdfa66ba4eaa5ee814966efd69f1ee1095db6cbfd6a1f4815bc15fce99e42aee1e7ff1d944b7ad0654a766d5fba6415c64bf7cdbd3fdad4bafe99b5b42d69bd5a1922703364633395ab643102f17811661410446d89b61e7b00a34eacf235f422636510f90083485c3704006ba13608b2cdbc7916c605ca896de3169459001a90c45e452c94526c60fe5fd7ba949801df6ca936b8fc83bfbca4735c59f584329f1ef7cf2b9be5dece4c7bf7be8b865165973cda97a561aebee44bdeeb374b3c1cae22adab22e763da61de0d1cff9d6a41317a586de10ff6fbc73f42e379bad53c9d2c4b86fe0edfa97fc424b7a8b74c05db7bea319ab15166751bf8e04b4e5dd2f356322c399244f8cccfbc42198dd3889546c83fe5bd8f292fbc8d94870405d10dfe7e25b2dac7ee295dfe76adfaeec777d40e20d030496e6c3876fb92ce6eb62364ac0c1461b3c57d4c35d3585da187725eb3e5b5a94318e29b63501314a45e3970689d032383695b5d44979e0d7edb8abc4afda5ebf3c0654a1bf29e7762fdd9fe3a663936e1e63306ffd88cd3918170dbfcfb9c9dbce5d50a8e28053c5d5c2ef61dc1275542487b50401b88d6feec2dba7aeb851cf108e247d9d8768df83a8a8e08d3f5a3877418d7ca556cda85f42c9de576ccee44490cf22df1e7e96987ca8f78a1aab25382b8e120de02997a86cbbfac62037e4fd27e1e1a0cbfbe92eecb67baaf8d05a06bc5b9db2da3de88dd44ff36f92713c3fb110dcc22d6e3917f3665d1ce68dce2b6b7934d0c90d503c6539b4b03fc60ce52c50bb381d1644f305f07bc91a2580657406cd936bcf66e0af9d65129f7d33a45f087585dca509fc124b7aa80d7e7e3e7e895d96083410c4670f125116945c0f1f6f7305fd835c62d6e45ed897b53d9db97b6a7283686115593e0030573b0ee52f696634a82f25e90419092f1e8a485d3557176a11dd486841ad4354236b2cbadc5dbdecddf5c1920c5ff82df7e3b1f0e2101fe81000a0b713f15832b48be760bdddcc5891b8d875843043e46c9413012aba1dadfd006184bbf0e7e653017fbca3b655b48c2e57d2201915eec282a89dd74b9b84070a382e194f33643c92d46eca27a3c53f0ad5da6e917952d9c569997e470445b0bfb1f4c75cc2b45a4c2499fd88b6700c3376da69a13de3604a504d531a6ae2ebf58b99fbae341abbc3a3959bd3c025b0a352617dbbc8028ebeabfe35d01c82c61e7430153bdadd8627073f3f5d9d58eb4c1c360c37003020569f24b29ee0d22802d0f74afb5a2a2414d32b635f003b70e863cbc6fff59fcac03a1b89aa101501a394e63c08511d9bef8bc05f809ece261e30330aa87bc320945b77d8f3cee56a0692d0452a767d9d9a5209411639a6a13b4d1e765ae68c4d1fe58c9d91bba74adbea8e2f4da025d4d9f73100f7972e7f0b86899f17dda80aaf15985654d60cdec8590731ca93756dcfb68dfa1ea06c06c4f65d0c61e41261426aea0ffbf8a8a6196e7944d7851e9437c77db5e4c86ff4af93fc17601d46625c72a2f0d1393599528b7bfb34bf363c39a0926e82a2dafe76443cb79bb19be94f4066b3c4721bd106becbca5036ac7e2da436e4e6fb2842b547f8b08079ec266d41a803de1ea0552d0c2d0b4ad76c6635c291e444f47b58acf3c110f526f80f7fda3a136c1255e4dd3d2aa4dd7d57731c1efb5c0ac8c22e641fcfaf94a01cf6c32672e65993fc380acb8b13113adcec1cb08c92c20087079976aa9b3121165b125a866b6cde655e4f574bd3812663e2a7bb65e7a1e00d145e20a2fae80c0d9dfef52797aed2d702b17462c092332c8da2980ff20d6e02b75f527a68f116667cc57099f7995cf4cb19c088a7f939372d29faf28d8d0f30507899e2277440ed40cf03d2dd20acf53f97e47bdceadb09b4cd2da7e988333897b0b59fde5d414cdc3d5c154944041f837c4513d2ee53dbbe67d2a3ce961bed26911db85d2bdd704d070ce45af80d597fb266b6e49b2469b648c1be35794df492d92c2a5f8964abc09ede14df0a3fc5f4bb6d9da6c8d3936b88eb9e62d7667f33f0bdb354328aabc634b1c165e551c817ec0776bb1fe43323d42dedb7abae9e17cd5d2a7f277c46411da6f04b5a25d705acd7b34dcdb4158800f5b66cf34b7e0ad76e617ed06fa6b71c77892dd66c1eb5c34074c3c5d7569f83251c0b905b09d351684c2c4638acaba0a3d29d8854548c1412a13f1de71274c1513df865637ab8e3f84da218485c26f4a6ba2d0e7d6098b7095697ffd92dc184c35c60f582e22ce3bdc7ddc99f65819bc8c44867be14abc76bca24b855b1e6e4e7627bd0efcc176866a2dcd2493295b60010978f80fc06d84b6a79ec342562edf8858f173a80f38ba981f64c1a4093e1b3a72fda31f8553720257df209fcb69b1559e4768cf23744d6ceb2a43748d745858f0d0cc626f02cc3eabe70f70ee3b9ca3f9d0dd2d10b19a8a03c259d4446c5a2b0f304164c7d2a3d6fb1991725acafd7444a52a901f97e480a029c70db31b65bb082ad92cb9f82911c7a2a80d9c12dbc4db6e28203fa4001d7310d4e28d9a09a194ab5ebb19861fe60d0950e44f73cdd1c684249c7318e6b1664c13c9299574de660988744dfb9039bb5ff961a333fe18e785a1e21d5e9f2df9c8cac5e320730c0c112be1577bccefed133e40c6b37bf24dd83adcf0d4ba5763e447896fa5c40704be003139bec61fad267c19f070d184ebe014bb7a855d0d249b84b5908f7219225b207861c6bd99e7df9bce9094c5ada1c90413ac81cf56fbd08ef9035d8dd917e831fc165ecb3698919a770e358e6932acc1bb4158678b3cb9f8b6d6b101cf333e1028834ce90e4444b1256b9e7343683af303a21c4a7b430b62ca16b7ddca1b2bf89b1192c331753402a18234bd5d74a5509da0ea161c00fe4bd0ae04287b2bb182b24e11a18daa7987b7babce80ee993007e258c9302a9719ac3cc071b58e35bb205236231c8c227f1513f18fdc945048f5825f4400a953b614d605a0cc85c08eeb30d2c22009334982aa12f61c9086edd89af4ce809fe8190c3e4e932f4e052780b13f7f876a1edf6fdc1fffeae045a31123c513a601e5763e6acc0d4bd58b6a47456be732498ee6d7f2eea97fd0854ed6a554e3d24ef49f024b05563768a284f59734ceada6445e70b3a5a842001c1177c866da92f7151efc92b1523fe975f32fba45225c237774dfcaa7fd80475d58536693560f8de78981b367fdef6a9227079cd5d29b0292ac7d2f2a988eae485949109b8b31b8859d2349facd47d66da0d11d4301ce6b10896f1b19e26e4fda898514f1a5b83dacc50f5515372f91c5144d812276ec862a4a098745808aa8872810a40b1b5408f0cee50d7adea09765ab8bc093de6e7ed7c03cc07a52c5a38eff3acfd792f92bf1843a523b7088f7d68d365ac9de54cf033e11c487d331527be3dd469c4393721bb1212f46e400f17752103e348c3a3cfe5e6a4f9feebf891aeabde020e2ff5103e435fc611280c93d57d6dd0d372d219082b909c06e3c444e6cd01c0bcee3cb81763e89f30a86813fb157bf6edda99c8592345a2bfa351e83a189f832bfeb84bd38fbf83866826f143bf56988760d0ce357ab08413eea4e11f97053fb34169cae623633934662aea6adff52d1432a368fb200de48e2977ede0cabc80640790aa8f5b690b4da1a10500097943245846ccf827a04aa1e2524c71ccb866490a3627462c03b92e3e72e27ad0bd13032de03e05ad2b77999a7549b1b4b745dd30665b99134c652da2f655c0406c6c6a44ba8291a4d31a8645b045f0f02e60a47f0668371f691531cd222c25338fb5f448a40aa6e9676122b349740e4e774f4aba40162c2dfe34ca247cb6e2c541d6064d26416401d53f3eb1604eaa20a02cec58d567ce1480fc801c7545918d82f66f0b9327b47befe60b634378c539f81da55ebf1b3810ced74b0b9940e91ef4667b1c27d040a79749201cfb0f19937a86172a416012fd59fd79c12f5366e62b9837a9c9e71b713917eb3785ec0004ef1163025c226478e9a1f1afb25904febe023e74d321c73684a66fa6017407e8754a0909dba75efd83e9634b8c978464ff27acb04a45ee4490905a531d12e791d4734154f7eec4c2c05878b92abb11bc532f43077e4c4eec57f4deb0f4b5eb63fec5b34214f1d8b26f680c39843efc393b2702511ef6abd436daeca0c0295164ecdacda05356c66a573d47494f21806afffb397357b165c0e46dc88f23c43ec2304b67c25c87d0291a29831f97d5f10b6d5ce3b826fb201974ed3c409910d90d2b7b6f0166480edea70e24b4c12b14e2bca777f954ed66dc193729b8991c352aa8a7bc3bcdfc17253c853822d8951a07cdefdafb73ef4f3706eb2499f5513318783cea9134bb76617cff507d8e486fff7a720921e96986775b43b54d68144bc195af09533a779eed66113827a9a93297f6f8b9e5231bac924c5d397b20897badb2d90b8fd3c5f3a5f5bcbcc49e3fa130f5d9cbabc6aa024575f8f9faf604aad119af5b74781028e24c57b1b80be181eb85037fa76f16cf6efe2e97ed9df509728eda3f018edea9d559453fbcf1df555edb61f11624b881908cb298c8756c5d89048f0473de2aca0eed6d4a66db1a76df8446ad5cce9ae330cf9af64e478c6ad461666f1b151bb61f6c4604c1ec5f89c36266eb19204152871eaa42294b5e7912502516cfb7cc4adeba878792946aceac6f2f0db3b9b7f565bcf432cbc7bc6e72a21ba94ac75601c4749bf787b1957d4b73ca23c0df9c4290b13496278269de9d854f8641fc41a7e772c1e377d0b28c465edf4889de90088254def9b29d8024b7e34ab3ed042f5ae55d125c70bb497ad16ab8f2b02cda149ada68a27aa68bcec874566aa899cf3d9f19a87891c32898796ed046148d191fbc3d4999b6796562e2b917893b9f1923f5475caf11d75791975980990183175ac55056d0d3cbe6612b4351a7473b96581bb21d79209276df0381ed1fb117b3c8016aee7aa7d2aadaad1d31d87c7b15a787bef93657e84bd062992da1e9c7f72172396798a7078431c8081a1a3244683670cc1ac1d67dc3ac58f5d414b54607282245298ed5990a80c9d471a5f7cbf39cf5857bfd5ab1d6ee7b26b07d1c242b272baf26468bb8ab08d56e65cfebb0c5ef7560ce42e8a7f8db493ca7ada1683a5c0659ebba7559a16c7f169dd39ea6770223cfc593aee7230dd6cda55747fcad49a118db5cf616450e1f05f8126d811ee40482f9a622c987997e0d6c4dd493dc3c5204ee26e841866c67ba493a647e8943018e6e512fbe0b158c11949ce29694ef7ec42f910c4e2601baa45e1c6957fab11eb6c87fbb85a1d8820400f97140423f29ebbc09da5a074b0ac2af1440b6797783501148396647ffd282a615a8470326804869a3fefccf480025c3b0a30540790f3b2037fd71ab95a7a230a818bbecd277b46430d08844d5cf025ef00cb5827456241cc16b401e002637510e42e175b92e055d43dc8b04da508f7c4aa65d38e315745d458bf8fa653bcb26129114dc3d9e131e8c36919fa58ce07b0545f9fa4abf69c6e20f58e7cf6809ff995d7777a69a183c250c7401aa2b3bad9fada639beb03fcd0362cc8a84022e830ccd0a0068ff3821d709da144eede736bccea86b75ba7b6ba99e0af4bc43a87975a3514d04132540185747bfa00079d93ba487fe26470e6b0ec3e8307e676101b857fad76609f93e21f8236d5b4d16f2eeef4b873d8c58a7532bb2e1c17d55bd1d6899ea043408192973f30a122ba8ef4dd2464942bbed95558900780f4e8716178cf3628be7b6c067d1d1bca5854b81a186ccfee6e060dd31618b8b74026787b85ed81e8798c17e22de4417ad86338d25cdddb4c65e482d5230ea49d797dd9b7353a0dcfcec093533fecf71971337b0569805af70e42edaa1dd68bde6b13788c8be854d5a408cd9817ec13266e8e916feb5f1d4e21bbfccda585bc76776f69936905356f97f42fa9ae55577cacd89006846235c6f1e2e1bab1f7e26a9e464c81f7f8c04d0e211fbb02d54d7c57839012ca04004ddd763016d3f1c49eaa30839ec35dd928dc6dc27b30940908e39479bcc5ded0328c81073f5b48ec93a36a8f6a3990f4728f7ce0bd9c842646054e750d0b0f0ca1d999aa8b1d8e3c6ad07b2d109047119dc99905415ad296302dbd281b2630b7ad7bfa01e2046748648f974df8583509fa7828e21be21b4ba433dbf361bc845da504a9ede590d79d4c2053b51f7ee3128aa86abf4b4e9ac50924f180f4b0cab10a5cedbe1a31f056477853de195893b1a0b873763d8dea6aa7c177f1167438247dc6ccf9901d4233834273d09aef029706ecabfe12c5ce12fb8e02e15398ac5baaeb8b48fc0d348ee7270fa4e626ab6d347f9f45920164e86f1d529603b2f816880253d5c645f55843d66304147f3f48251817f82e5b61d1dac17256578125a35c1058114dc8a9a596cbe681dee9445701e9f1248179d32f268153b9db469ed3024840b5af7e080ae2b517db1b6266fc3c1c3b7f5ef00b877ec32530542b9b993b3036988d0d656922dd7101b835ce422a25be82603a80e8dc45b3e7f0097e0903447ba850b1cf90ea836b8c16c2e650417450d4db5434661cb1383390dffb2f5987640123cbdc667ed57a1f47c2dccce92bc97947e0241ae51cb9280263331babf2d664ed3b17b22c0fa943700af0a581dc86fe2955e6803d19aab8099a411445e7d4289a82b1c1dea6e7c75a3bba05a61388916ae18fa53ff77716132ef2cf74ba9f14832d1c2ca106ffcf8b02a67352fce799d86b7b58c4c501d21473db4d93a74b67d07758395d0586e6f603b125fa784ee8d490c056a3fc795b3250ca03c48d54c5e79aaabb24bbb54350c3c2eabb25ea77f0b1622bfd0d570cf8e38f3e0bb39d2e6a48e105b28f58d4b23ef75024752ae60cb67701d02b7a422be55244639cabcab36fa82acc2adcd965dcb0b6646cc9d2008e43464e169a01942bede00b41a180e343fce719e93ab2f7dda4332ba7b5db9944cb16ca187c9216e3a7d1556d6251cd02b3a25718e8f37c0f15ea14c4ece56473291adc0d91dd247d9dc9c72ca786d728a46ed5e2cac9981ef3893df23dba4ab2ca19991ea14c47bb11cad785e9500cee44aaba7c08c3f0bbd64667510f30183d5373473ecd01f8c599f0c423c468c5ed74d6db1a0d689cac1c126d785f3dd1ebb646c847e36c2824cee52aed625955dc9c4b01fe455b935636fbe3bb684316b921183d08dd4b83c8653cc9ae7ff979db5bb32c1537707e8d04fe6c7f6e32be0f54ec607849b0661530cf4c1a1ddbfea36478676cba79b6df71a5002606906dadbc3844f7ddfcebf4abbb32e5f599277ff86f3018f6c93f1ed567e3b7414c148452d8c96fc05fe366fa1f1d31bcbfb056b42659d17b49a0835ce96ec38dab4a7a8f088f0b8cdf11a34bf11462e1792ed359efd32b0eea0f44129a6709c0c81adad4960b168161ef8596d36e7a591b153d2b00de962adc50d740b3ef0d7bb27abaeb394276539df0934b2d069c45c4e07790e1020ed459f8383fd07aa8ba21be4fd7c58dbae1f979017e41a5c9bd94f5673292a2a6b6d956bbe6c0a591b35dcc91acb0392e819b7d2499bdbeff28a1873e026b1654dd7e5b0d43aed0494da6e1aac005e0d5b707010bbb803490d315655a11cf64735d3d73ecffeae86b9654ea60264a5d041630ca23cdfc1f12d6dcaacbe2a856785111d0c68516feda1060bfbbb3469871f07dc4f509fa105caf923b81fba87f21d31ab197115577df8dbc57f49bc15724ac081948f60acc7103ae6800f6c97fd91284595d95316a845e5fe1e4c3d6869fc1ad76c8e3688be2ba8c45bb3375ac3dcc42fe1eb39b27ebf2acc9cd57e40ef4ab7a2348988e945bbdf81df480d70fb43209c515b9eb0f641297602c331f69f6a7a97477cc2128687918517e92000d4dcd498b2f24b8956fd0b3c62fa2d0dcef0186b3f62847c684934eb2b78031521dc5028be3f50367e5bc6167e1ca69e2f1d2a5678e83549f14153952f6ab5fc927e988948e3e4ec3e91c1ee1ac07f811a16a53059a7920e05eb3d2549d8891875604c950a4a149e4ee8eb3c54ed5d01510908c29928276aac6ff29bbf9e58ce3401f6e0c15485783f729872032e51c032ba4a0ad5f1efffa60885b8004fedb3fce327208bb9aaffa430e43a285e92b61ed2d3ddb953ceeac0a0c1d5bef62387dc5219456db4f0096862030ee7294e40f3cee3801b86b1ce7a588cade151bc75526724b60e67afce880ea2aa211cae55d17093ef7ad92f0f0150c89fe9b387cc9bd2c044ffc22167efa3917247a0cc388dca8ec4e3eb17417e96e8303e0081d003464333ce5368441079064cae6cbfb3b3c63aebceef952fc6e3c8235c32e80ccc855fd4538662a8f8ac2120d6cd78e5caeb3662f004f680147bcdc028639b263aabe2d6de106476127cb3794abc46a182fc4aee8b04774d97a06bfb2feab7d06da1b8a72aa2145fb529068ad941b4f25bdafc5efc3fba93599d32435c5b0477b19d5d45bcf5b7cb0a8e318606d9494f8d7e0f7e3b5d828e7d61cbfcd3bb0c3ab593bece1627db54a8ee248a0e3aeec9a0d971f10671f9f0c709555fb8a172e541f9334b0176af1b9e4666175f289d7203dbdd7404da884c45f2d812437c3777a07523b3b5ba8071f0e2577568757f9b8bc76250db1a53afaddb21ca99b486ad3c2ece57f013a27054de3435c090ecb7945bc663a22360a90f5db012d58e6d9457bf6557a684b50e59d59302d53ccfb05c83ebefcd476f514eff149c7dede9f4f6778a7285d435d75666087a7e7d6742489e59214aecaf4486e47d0498ae1993798ede53ffc76d1727748a1f0a2b7e9b012405d319e124e1609af88086bce65508148062003c1cc683de0c00f719deaf5706aa4227f3d91909247f81b4e181e7a9eb81b10393b9949be2d2b1b2fb50afb6394b62505e3d962c7feecd2ff0021075bf8b9ffb886a158033787f02f428d3f9771598302bf4fd04f2bf1df2838680d2eb3206934affef8fa6e0c1dd49082bfd388bc0d120c8ed35ae3a43b959800164b1900a645d84cd554ebe0aa5b17b5b5100ff17fc6dce457578aced3d776519251673f038e0bc5c73bb0a56fc8c8a6642021ba5574761ef31cde1b2fbe9b57e4266163d72ff74a59ed903c09adba185ef222c9d9407fd509a30ddb1766baea834e0a9cca475127e37cec948895d9c4b2ec28ceae6fa05a04472e9968b46ed51505c600e12ca6863d7a63b3e0e02713372d59b9e9a4d38c27dd20032a3690116380102d0b97f1e83229c56461f6dc13857afbd1710e5c859aa71f1fa1e57c692e3a861de303db97b276471067ecbdd61de13f2b7a280a42491687165bc399a3088ddc16321a07c965353a8c3ca909b09b46d6871457af5e92a279524112a54941f14a70e8b3aa8233d258d295e907710ea6a7492b474c4c183bc2b62b8f5d67fe0613bbf3a60d50cf72f3673181febfbe69c1835476d0ddb26e537763db0a3cb13d5c6680c8431bf0924a48931ed798c73a34b611cebcf9e9f67503ebd6d69253351eec846dc68a02be67011498a5a6bf648543edef725a6de67093d9acfa8fa5598c2afdce97b2f302e9322ec077a964efc1deaebabcba8c0b6033061c96a65ec4ef54b74f3ffab43155d97d18a33ca077bd36759822336303fcfb663067b44b0cf8ba408ec56efe482e7ac1e0364633220a6a038aa03311043900b5708bfafa5e3ad2a72dfb307b6bd19052dd79f36da76f06224b1ae186a50058fb548862ebefcaefb466e87b5169d1ddf13c9b1665563ad6354cd91061aa0041fe077525c7420e37f93c835550922b8fdd90bed4b67ea394977fe10e45af2777ca82ce185de547ade5302a6e39e8030da74c8fdb617b2a248be3349b819706abd55a091de3f6109340b7fd9e194a42ccff8dbcab12cf51b51ec8f1993c4ea17d94baf2adec86336ff04db6b77d363ba1544bd108813ce770a6e1f268a313261111c912ab0891dd61fb1438bd37c42221727f8956be9e5cc3464b88fba61362248c83f0b0c191db13e0f2186a5355937da2f57ef85b3527e96c7c5d275e1a4714ce8dc211cd34eda0fb7ab6a424a4d366f41f636f24970bcc54f3b6d2359869ee3e4644b57cf931584316776f33bf2e859108bf2b27b0a88f35373e2403ae308ee4d95609f78f36616a8a1050a3fa62a79e3fb2acfee55ae4a2b5191a9269d41d6916e7d1117751c489d5ce60a29b975c6934e0dc096adbd73cc39fadc20548699d454273597b24c5badba48af4943e8acaeeffda500dccce5864f0dee48ff66f97d9855052f7f68b020338575b048169ef6bd938bacd995a7a5ad2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e10b84816b9ca8113ba8ab3af52c02b1"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("d-none");
            document.getElementById("staticrypt_content").classList.remove("d-none");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("d-none");
            }
        }
    };

    // toggle password visibility
    document.getElementById("staticrypt-btn-password-visibility")
    .addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
        } else {
            passwordInput.type = "password";
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>



</div>
    <script src="/assets/script.js"></script>
    <script src="/assets/bootstrap.bundle.min.js"></script>
  </body>
</html>

