<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="CDVL91 Comité Départemental de Vol Libre de l'Essonne Parapente, Deltaplane, Kite, Cerf-Volant, Boomerang">

    <link href="/assets/style.css" rel="stylesheet">
    <link href="/assets/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/css/awesome.all.min.css" rel="stylesheet">

    <title>CDVL91 &mdash; Comité Départemental de Vol Libre de l'Essonne</title>
  </head>
  <body>


<nav class="navbar navbar-expand-lg navbar-dark bg-ffvl-col">
  <div class="container-fluid">
	<a class="navbar-brand" href="http://cdvl91.fr">CDVL91</a>
	<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
	  <span class="navbar-toggler-icon"></span>
	</button>
	<div class="collapse navbar-collapse" id="navbarSupportedContent">
	  <ul class="navbar-nav me-auto mb-2 mb-lg-0">
		<li class="nav-item">
		  <a class="nav-link " href="/pratiquer.html">Pratiquer</a>
		</li>
		<li class="nav-item">
		  <a class="nav-link " href="/a-propos.html">À propos</a>
		</li>
		<li class="nav-item">
		  <a class="nav-link " href="/clubs.html">Clubs</a>
		</li>
		<li class="nav-item dropdown">
		  <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
			Articles
		  </a>
		  <ul class="dropdown-menu" aria-labelledby="navbarDropdown">
			<li><a class="dropdown-item" href="/evenements">Évènements</a></li>
			<li><a class="dropdown-item" href="/sorties">Sorties</a></li>
			<li><a class="dropdown-item" href="/formations">Formations</a></li>
			<li><a class="dropdown-item" href="/jeunesse">Jeunesse</a></li>
			<li><a class="dropdown-item" href="/action_feminine">Action féminine</a></li>
		  </ul>
		</li>
	  </ul>
	  <form name="search" class="d-flex" action="https://duckduckgo.com/" method="get">
		<input class="form-control me-2" type="search" name="q" placeholder="Rechercher" aria-label="Rechercher">
		<button class="btn btn-outline-success" type="submit" >Rechercher</button>
	  </form>
	</div>
  </div>
</nav>

<div class="container pt-3">
  

<div id="staticrypt_loading" class="staticrypt-spinner-container">
    <div class="staticrypt-spinner"></div>
</div>

<div id="staticrypt_content" class="d-none">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <h3 class="staticrypt-title">Page protégée</h3>
                <p>Entrez le mot de passe pour accéder au fonctionalités d'administration...</p>
            </div>

            <hr class="staticrypt-hr" />

            <form id="staticrypt-form" action="#" method="post">
                <div class="input-group mb-3 staticrypt-password-container">
                    <input
                        id="staticrypt-password" class="form-control"
                        type="password"
                        name="password"
                        placeholder="mot de passe"
                        autofocus
                    />
                    <button class="btn btn-outline-secondary" type="button" id="staticrypt-btn-password-visibility">
                        Voir en clair
                    </button>
                </div>

                <div class="mb-3 form-check">
                    <label id="staticrypt-remember-label" class="form-check-label staticrypt-remember" for="staticrypt-remember">
                        Se souvenir du mot de passe
                    </label>
                    <input id="staticrypt-remember" class="form-check-input" type="checkbox" name="remember" />
                </div>

                <input type="submit" class="btn btn-primary staticrypt-decrypt-button" value="Envoyer" />
            </form>
        </div>
    </div>
</div>

<script>
    // these variables will be filled when generating the file - the template format is 'variable_name'
    const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
    const templateError = "Mot de passe incorrect",
        isRememberEnabled = true,
        staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f9791f5173edc320df12ba0b2bb6f34abe88b2984ab751dd15c8c7218cde7c90d39dee757dead5581304ba47ed7daf0f36da38354d1c6ee37098cce6e102b84603f5d5c07412802c98188907e1c18fb2fcfea55c7a19b6f260a0d6feb2b4264d38a3140ad1ba3ecf40a1f81cfe0be222a39b999d3a1188faf8e2ed09ae30d6fa6340de05283e1bef0662b94286d21601a528c4f3e25b6125860c9b88c3db626f8c25dce721c289f1cc391e253ffd94667d239ed552478585eb3530a999cc6dc2e3222bad06252dd63588f1ee380353563a268420660665bb386327dcb6e7b3641d8bb8455dea2e182b08af21490701d0632bf794fc0a7362892e99cf5f0594a6ad59e62fad2af26ca83390ece2a37d1c21137c7b579d1eaec620ea2d182bdded7b64bf6995d393ce77ed2ac7872c4eb3b987cd828b68bab8833363e2da8cb36d2dd9658cd6953aa30883290722fd24aa93d5651c437b7ad234f89fe2e8cbd00be39412ffd2c6327b423deba23e505c5df96b1bfea87dcedeaaa3b61c77fa3eb4d0527a95c982be88d624c8021f7fb8f4168be06dd6d1f8c751b4f06030dba170ee4e1d152f78ca90956beae21823407433613a98ba4e947a908cf805a3af166c0fb1f7219a51f4ab7b72b68ddfe06ee93596aef1d99477e100036f2cf936d5c271a79031449721777e45584a977cab74e13bafe826cfc2788b337d7e895d8ec748d322879b77bb55925fca37499892e1b9b7bd681f2ae426a798efd9ec22f9f213819e592042d160df5969eba0ec721c857cc51135ea90c285d56790aab6036e480979ca0039d698313b549744028299006fadf27960e0931f0d1df707849b6cd0e7e92315cc0d265ca2cfedbd73457d367acbfd2bbc0a7f7a58bf17592ad0d2b8cd518b65538adcbd983f03379bc15ad3217d103c58441af80e0f2654cb6a2770491f4905085c80780d24bd4cc90b271ef91673e924151390e21b8e4cdd84bbbe48c0539a526314eefb6b49511316600ddcdba21589b5d64106a45b2835e3e3c79dbbc8ee0bf1d6faa54fc71e3848f0d98d69ddd2f362bf78fcaa5de3749d4fad5bfff65afb293267a235cbf0d573723f278b8f92e100e6bf333589683bc2455b5e23bbf986ea51010437470e11be8b1b054dd67e8c049e6e5477e0e6db5dae74f85acbdcb0a1ba55a77b81892813ee575396eaef80995185630dc09642ade9b80118482c6813017adcf9a8766a89c8c45c7e8038121bafc8e4bd712139c76d4b6830d3b6e00a0b1368b0d70286217c02a8cee97e7c074c78f0c39bd64790807cf111b993ea851a0b3f1611282d61754cefcff4ea8490c6c87d648e7bb2f251ac15deb52f837268343af6ce73ddae553137bdef621f3df6480cbddc5d0c33aee49d4e46e5058833d1d40241c323697863e54daa9a6ec81cebab221886f4fc37f181dc557fad4ada44d35a1a9e63e13ab97f0fec9ca8207490eff2f8d5b2796c02a9696910ff97323b93285157536ceba9cf270adb00938fd1adb961f64654c580208f5874537b0a077f79af67d57d72bcd4d41aea8bc62235b9a3cd3e710d26b770cb10c888e70ab2bb4c11d67529bb0e3a5802331c491cd04f6a909665e53143c17a98d8dd0581f40ca0ca2374e0e306f8d83bb0fabf738839d93e9bb9c99c6f0d8bce3f5625f612460182801379d0ec9e026df8125d6cd082c3be0f9bcca1fc994854fcc87f479c45de263a4fc132fc3d510540975c93636e1b24320cd90841cda09330bf21e93bea68fb5f423f602724ffeee740b7b6b30742aabafdd90adee641c43b6f1f700d16d7836f52099ce77f45396523d7b9f99fc61bc73a559a9d23d74b9914e796982bc1ef3ce1147ee65fd049a90f8c9e1ea5b5c4aa8f94c1310ddf0ba5898d48061ae7a3bcec2798ba9690c371b85c69f85c94ddfc476556bd164ad5ffd3ee1767e6065a963759358241377ca1d9d70aee60bc0a55bb1bc7486d8ec57418fd9c208e187544cd557640ec83b5d9f6cc072164b62576b2cddaadf4d07f2068ca99afc077f2f3d04f8c2ffedb2a95f646e1d90d8e9cedd83f48efa76c88ee78819b6ac491c26e27aceb3f580672cf710725f9ab1bf46cad41e2df33fa0c12f998ec942458fa18609aab7921da10f331f5a1ebb6ac3e1d9300d199bec105540dbd785085c63d82b11d2fbe5e2f4335f4130031f7b8a677e04c83e04d7a204f61114bada363d1aae991b3caa4044a2ce6a1a3df17d6687559560f3a960ffa1c9be717fa3c3193f4fc9840bac7ff610ddcdab137aba24f0a8a4df87211342b58f9c6bbeda3d5f12c20cb59ea408084aa8285cbc11884cdedb0f4dfe03382e740066aa251aea6b1db3da2601698748bf7e1191177d817d589c543d959aab90b4cbbedff1415e82cb288bbc596c002e2db34afab58a97bc418c500743c7ac77434ccb28b9f55d828b885a0991a2154d3ff84329f3089b81b9dce4fbc8b34070f23e14782332630346917571dc589e492ab27aad382c15dd38848294cccbc55ee0ec0684f99170d7f75d76c59ed761091b0b561023cfafed541b7c85f27ba4a5faef5f0ae4ba037c8b3a1a92ea52a8b5fed46e1496bc00d61e61dcbd129ebd6563d422c059e4618846e849ea74aac9ef1b8e858a0f40525e744390087ec5232343e59fb7b2dc4eef242a2303f8e187b4e4c544a35d283f2d1a804855c77e10fdeb049028ae9b7b82883283868747cad53a0cb8fb43ac0f5124c5510995b609ad8a500bc1b8de359918770c16dba70022cf43fa546c1a4ff6e4618c876916d204437f4db2c924bb2c5cf11ede38f014611da3138c5657d211cbad1cc1a04f38823e5e5e915e642eae35636b092ebd43652b2b6ce27e10a577561cccd34a46a1eac70f3dc769a399617526dee8d594db2154500afa052f8d4b38d1e4af7299c418b329705bace74b73b9fc628a3084590365422d41cdb1fc738301bfcdd67edfdb0726e18c1cc1e9d7abf95a33467e69477091e119f9284d9f2ddffae32507d7bb66ac8fbba2b0925a743f52d2c631b84e171c5aff8673c2e3631189d32ee794a6da30b8eb7a68015517a039bc1c2a2fa37901905cfa2ba93dcd4473362c6cf9fc28cd2e5936e44eff6797163276d8f273573d52be05a8956f32bfdb0f0f0c36791a2f75fb905dc22abb736181c7a69599dfe610b62b8fb4186b8814439938afb20ec1af5615342c5cf365bd9776029daff5bd7dcd40859f6e897a400da760a8dd3645a46dd82cb54fd152ac277514940e95d2f363a5b268284ca151a9395b28c78ea5121c0df070ae51b6f25dea7301eb89eae7fc3e2ce3afcc5b50dc94deacf767348b9572b217760beccca4e5f4108da8d8f0c77cd309c837e2d63be75e7d0d0402f6e69199c07330b7b20ae01bbd31f1902e8c33d2017cdbc7aeb926cc9635a24e90e9e0af91a4678b047c5a387d1005f6f2b8350c6895e29b9eac7cc31432926d8ae8cd3ba194d76fd8effad7dc41815ac374e683eb682ce08be316c3aea7d4567c60caf0090c99e4505ac3e0e4e07658d1adb9ba65bb57884bf25247cab2a1fbe094d195d94923d02f41cbe7b56770cb13576c9a2a107c32a162d7c336538e8fb8b0143cdf3040a33673b232a704599bbf97a0031988138750afd5c0402cf5dfee02c9a840dd9d850554688d3474a6142c684a90e1dbc910d4349ec9de93b648d6eef0e10b2c65372966a50ccbd0f1a89d89473d46ad0cec0d7df42c76768b8c71f8a94c7bebe18b26ffbbdcdefe638092c61ef1ca8af0f9f82cffbe3c2b0cf0cc407c2a5ea305f67ed8405de87cff7a2b811966d9d155d3a02bb68aa629870796262b62f255f2c94d6838b70c0bf51a239db53be88aba304b69ab7448f89cd4fe1cbbe082d3681665e784aefda08f2f097b291b340681a15093764ebf6cfd18085af5e67aa30e30c462ce064a6213ea522b40f9220062a336439b1ac0b6474db79f3ae1f6a154632e4ae8c6dc0a25300d762c4d2324689a3569e8ca9e0ff483bf5d999689d6a02b583dd1d24f9b118d7c71ebc9f9ab11e202ee21fb2ffecd07a74e29f8e09337f8ff47f1e5041203269b18e9a96552c7e55fee8e814391da67d783eb2b89f2a1bbff864c72bcbfedd30bc1efe25711cd36111c3df92ff46c2a375ef205a3514b4170ce90cc6df07d63b321e39ae1d6c0529e76f420e5c4acba158549b4bdedbdbc16aa5712847b700ea1c1abadd5a8fa3ffb4588fe76bd87fb7a65e229a1e235de99f0eaf1045c1964653934cba2d72f2dd9f21bb90130b00a05761b5059c3347d9df793c4c8f44048de67af0eab559eea399d165d429a55056ab20b4758878e2d35eabdd12e0f0eb0faa4e95ef9179e132edd6170b3eff011cfdb95272deaad68b7f2f7a4df5932f9c0205ec0e8ab27e345e04a1dfbae1f42cdb4255fb93bc694b8fd07c1530763e35e46c5ff33de49b503d6be51999e696ce1b8f388b344593e0cdf8e52ac8985cbc15e7329e765aa60b3ef217219e4c6bc390e7e119b60e54338ead0bde693e30438da91ce95d11926f530ba36177168abdad076d79aa0d1c3a1b46675be2f5be6b9a04ada75a50ae3c36200e09bf73e1d32bc407bb81f25c889c602b9f796897ab1b1ba754368669658b670120cf526c65554e63edaa84e4e8e7a7ba1985448799e885ebec59bbcd82b08da053c4e779cb388935a25818591d8326196765c7108930ccc3486b246e66aad1b3e6e2286dc8dfa2695cd375e377080b19c3b730338a189adf4cba3b6a68f98ba64795ca096a9453c548bb98244a271cfb5b166cd117542f1906b52d3b87b02371f71ee0c28654faabd203c522f028ae0bf43e4fe474c441e5ef092e78903d0501902fa254dcfad402b30c0862f021137f51e81da69d9463ae8c8500d6a3356bb604beb586889716c64eef14fc8800110c9c667220cfdf714124988a8abf076b192b4acacfdbb282ee4e606ffb484f41e714dfbdab02b8ca963f6f4e3d47217b7f355119b869425e960cb353af91b1c8327a3376f0ede20a6bd2be903d2b74b40dd5e088ee22302dabe2445c42bb5b02971193f0340c96e20e9f0d49eaef4312d79d33c18f545673bb93e10e177cb3081f39937974bf6fb531b12fb742e34c8fd76e31c4f3013957440d03bf5fbab1d494ee9c4c0e6cfb9656afa6f04b3df87886499b1ef5af3735e1cda4021fc1cbcdd4e268fe35350451c479931b532672ff3b4994f6478e844997953ebc6572454647c25b6bb56bbd405e8d235b83329c3c1bfff1dee4239603734c2f9066d063a350d55cc438b5921ec5f93ad09162db3414f2b3fc7e02c1fbf695217465e9a917f1efe3e95329ff134fff338de9fcd78e9ab8c1d2c7b2dfbaee6197d87512237dd06fd6aee81abb0d5305ad4015c95f312ff374743cfaed5b88955f8ed5d6a3360b6f8e76acc32044746561f824a45669000952415d84226d90e0bdcb91c83602097406a15b54ee6776d0060a9779ae0693285385c9913c7fbc4dfa204dd0499014b426dc4ef5d1b616f92427918662b825e03f259112d467446654e0b786c493d41c9005bb653277cd2663ecfefa0911bef8a4dfe57a4e55e785c16923498f3c71a9c782c03bcebb812390f64d6216689aed954680b40d6e364aa6385f70e2dd62b65252ea32631d4155966a1792da2b29ddb13b3b4de4178ad8edf8e0544ed0bc73063b5e7b1e063be78cd892320d149a15e59f4fe1cd6c5b215e607364bcb1c625b14f30acf2c6d27683d2ef91a49d3c4eebee58f9bac612f4ab0300d4298bbf5cb2a5c801c0cad573fd776d38536f8fb19aa6ffc7829ba4f3404f057b9872ae67d85d6712b8a0707de4034b546616c42076511fa20f77355c7818f824e0753869ddde70bac04a001c2542958c46a71ea89f283f5c6903bb1f1fe55b8630286c71a19e42709420531cd91a9d04066b865cc683130153509bc1a0c484ce94116386095ae69c9a7be21d1e8e34a5d7de938af05b35312f0703a55a832669fa146264bdc6c2cad51dea7692f68c8ce37888d2b1b9c6c5b0017530dac89fdd45c5792db5c5ebd6deebea79f07e94c4fef0c1f5197c4f753d9bf0b6787b68837551c491e6e0ccfb816f162ba0868d677fa2925def5a156ae9f7ff98dce22c8ea0b74890bd919caf1f0548c19802d6b5784cc07cf4edd44c704fc5afe15f8e6b652b15b4369af59f8a960923f75f4a7a5493df41798ce4f95ca4bc3cfdbfc13ad293915fe64e788058e47e4df1a090b0a83cd3548967f5811873cc95e5b03079ea12e4e6c817ebde0e12ac407c6c46828f9e97905eb0694bf4b986b17195e0bb73d0db181c59adfa7192a8bac5d36ae810f80cf557bc796ec33a359bc31e15addad8f2719e80598e5cf74db99df815940c0686277bc21bf7d0a88581dbd94238dd39efff9d1969670fa0569eaa389da525fe35818a2bf6d42af1e954b702f10dd10d8bdde11f4f2b4a70d2ac831d3fd54e50474dd5e50e5c7e3bf9147612b2596818e1d7cf5969761e4d8fb43a08ceec2a562cb45d72bb681a34dbfb6bf8ef054c6504f6c4cc400a84e4e278f43b1dffedf9d84aac1328fd08afe4b0e30985d2c4f72161c79c4a2dac26e4e71d2c35c7d183f5d84e4014ab2f3e5b65df932447cce8b6e4cfc15c1b9c381bec8d486ead47458feaab5fcaa56e3e008bbba0b954b3e7bb5009d12ea16e552ef8026572c2d0f1769a9b4b04d8ca8e1b90fecd38fe660b3e097e636e48f9e2d3928a3c3a621fd0b5a64e8515ddc3eba187f725a7e8c6220501e99926be1d624b013c60a39ae1a01210071e63c5acd5b843e4ce884d1e36dc0b52ebee722c1550dfb30cded7c24d7a28ece4d01c34010c54aea6afefb44adc6e3cf9a2001ebfc8a76e2bac09081608f90d0fd81d8a012e8eb1781f56dd680f4ea41fb470a6dba8fbe3f71ff6a543d9f398b3e107b8381eff67f6245e43bda0e91f5fc6847cbb0ebf907b3364c8777c58827162dc4ded7784d76fdd9fe8c7800cb75d1500abffcd8e5f52075dd5e11720652cd448b870abcfdc8c27a433e80c0b1a058ebd954ca1cf16a22db45eeed67da946bb5b0f30b4c7494ad6ab561d47aab4af9f02df04720b7d924452797662afdb7d679267f9d9e19ccf1def54c6c4252dd06265560b6ca7a3d56e576f3510247c5b0b3a134fa3f4bc40c3d8cc7635e481568e9a0f78ed930e78564a8eea539b776d4334bc1a468692e2654baf2ba614e7f433a549a58051ffe3fba8cab5e72d72b4d77229d66aa3500cb3ee55b4cda65878a901e42e5e7ddd49367c868f48b13fc5f956abd1fa1fb88f64fc2a264f4414d2e479218f1d1526c23990314210fc99bfe85e3e858bd841b76a08efa8190097a4b77e1d126972c371d72c43aa6fa03960d90d22f2ce25ad210b3f396718516d2efd3186a48580a8781890a2fe18a19047c8381bde6c0f79eca0f60b67bdbf86ce372901d1d9eab38ad351bd16fe439a328cddda40efb419139a79b2a6cb8df9b0378d81f36f945f39bc112c56674321a65acc714f34264c18749a1c16073ccb21ad5b746fb9d98123dc5ea1433c47d49cf5a8f427f3e9db2748722aaa6eee93cb61553f3cd644c06cd6f05234131b6519a22f987220f64012d47450ba24544e8dc3d410f66c1b32cb3a329b7d2a5124ab2c94d3e11262594c5912a5d8d4e43e14b356b28d9deb5424b7c43cf1259020d22f2331dc3e9f2676daf26d24fff18aa9206fe1fe6ac3072386c804deab42dc9336772f43ab1a5e89ed3c324144ba8328049b11b54ef77680bf3d3eb2754f179c178d61f9091868df2782075bb324492511be5eb59e101d4624f9d870148d15fd087bdb2241422e547c95bc5de48a688b9c5027d8f5c2bcd3deff5476359309b14974ff4d0ca546a8d819e7046902329d671f401a0c1ccb836ef795bb9c69fc34dc46ff23362d243f3b73c92008615f6bb78d57b16e40fcdd119c9a8ab5fd371905a8fa4b5e0b13d0fb7ad166a04f0d1419e644ed5fabe4c5b6f7a99df36f9b5b3cc0ee91f99da4ca635203382053f093927c57835a95d3fe519384ff14c373cc7dc2cc363602e38746c91ff63dae0c9dddcbb72071b9757d2f3be4b41b24506231f795022aa71333eea6f203cf0e6318a0487fff73f8d65693206b8bba88d278e3c909bf5d6971006f188a6acbce4ae2a5bd5dcd52041b8cdaa1f5989b76e561d363e92cb6569f4a70b36028809aec820784d9a3dfbdf326545757ae72c1819d712f2e1107df3bd414b9878c80fbb032c3c6b04af0c3928bbcaedc7ae71e095bfcbe0179ad8e3dba485f44bb5abd796aceec0bfd3d237f847ecb22b06b7bf992565ebce9b20385b5e1bc7c74d5fe1077eea4e66f389da173e01c143c56d1f56bb2934f4977960c2a9d8af51fca99e90efe821888ac7093a1f58632311ca6db37ed3e129927e1842027388ef3c0d74847cc2228433ba6d85f3f13604f59238ba5ce2f17da86821e1c8297377b04c9171226907dd94f2e5c1ab8ae941592bd039d5c3114e049b199135d30c4c827d96715fdb745545ce60c9e7dd911fd5a752b5c2e580270bb5f6dcb56fc78ccd406876d3a76e37b6cce0929520bb141e74d2b45c85f55cd032485701d37c540888c925e06276e7a96971d0392420df09095df60483c7e5d3430777398f9b77ce3688f71bca1ee888ffe16d38cf9554bfc428ce30434096b9bd4ddd7dc11d180b8586bfe2d61920afae94fc92d8a7cb5b1b21e70f09ab9e69d558766fe0e771cec16bde093d5981e23c7bc228743bca1188b85f0c301b51c1557cb521b063059476874f5a8c0bbb62c5b896e3b8b7c55725562b4fcfb695e7e95c554a97fa45fa59ed8c6e6728f3531164eead83ace807d976a65d3cb4d76e991fd3a9c511d163ae33f8335f4f00ce54e3d7b8c31691e334e8e1cca5b4d9d0e1cfe08ab52e96e0a49e316cf9a5f48cd7bdb5e7101c4f92c6b9d41257be702dacd3b16f2ac351908741fd35b1727f39206b1878001480108143a1bf009862094509765da04cfdddcad7426e688ff7f774ad28c4ccbb6fbab459c8a34e3f25355364adfeddbd6765eb3d9594044a4de45ad7748fb551ae80dd0aa84ab343d24ac3779b1f366a05b8bbd1f5fd51336dc3b617f969ae776828fe8ec6f62e84cdbd3de697b3cad1e543b36cb2b9122c9ce9c9ec22bb54a9df5c90deca832441f7e5214493869570cb2c5ae7e2dc0f7bc435ef03dde35fb18fbbf78232ffcdab71847ef7049c2ceb7cbcb14b12770354d19ee95e0a2eb22bbfb9d06e9a20d292eb78c0840519567c80f3e04ffa9bc34e076f3fc7e855c5ac8d09df3e8e835cec7036b0df26e270a9f8f3569af07e91087a342f7cf57e20f4d3a71294705405e97bef4e3936654867fbd8b1dfae112ec63232948f8fb7a60125802d67a6034a35f468cf3d656e0841a71159b0f31ee21a880aec6adb177c76e47eed6d7cb86ee364a2da20c36007bca7b1b133cba1562d72404b4c3de5c47b1378f43e8c632c244041756ffa7bf59e2f66faef15c939849e32c32632c4411529c7e4402b9ff9d1ddf6e8544f1cbbfd8e6421d70551744c3a9b04874b5ada55fdafb236c8cae0f35c1a5e292d9c54615bbf53cc808e0198b724be8a0b911077fd6fd3294bf75a2bde41b395964b2ee4e958370a1e7122e240229d8f07e17fc1c9a852af7b772960974e8a9ee05ba7bfbb31ece44610fd80f7e16478cdff7e171f27dad4c33dccb19eb2bef445f333816c8df5bdf43cb25aa952102db7ef32c94025de59b7ce703c59c4d009102b963f82d8fd18c851a8672f0928151fb9b74cfdebd45a95a03ae6df9c76604b6521e35b9fc85c8f63cce658a6d575769117ec98ddd4fd924d707e32d13ff70b15f9fd61521b6ec408a3aae5eac534352d806dda393c5cfc4cada2fc2c6fc0d327ec0d9c6e12e47c1c3c30107f5f08a7002547deb9f9c171bcc5441b358ab0058c69cde3bd1252ddea37280cfbdd630f057ab225f7d9a42de358cc350654791eb5ff9c486c718d7acb557ee92cf59759447d13485f7a5b2e3b0f32d99399b65e33857b526c28c09bd98fe10687ace5d1ce13bd4cf77cb78edfe3e45ecdf69c21951efdacffbfd3e05aedf4a5dd605ea7211d78da3d56f4add649dd4dceffb7dec2c057b1add49170f29589885b67815ab0aa24ed5968e5225e2c721e67ae3e99b0731249ed6470417d8959103f5cabfa29bd9f74afbcdc75edd8cebb5eaab0790643d7a924308453d25ff29c4d5855013ff6bf7f3c3d71cc58296ce2a632dc7c9a02576eefc889a170e02f942c416cbf35e5e8e8e3f5791899beaabb505038d139d32a9db8a24601401ae76a2326fb21c91fb517e16f19915e98879fedd5c90633fe39619867f5c0c68b8c62e231f5779ff8851855a9da555387672beec2b6c9147da9b9f7f832b60c729eb3751b631d7ee83c5afe3df037bec5d3f02e1b54e8103a9f4abf8f721364f50f41bfc7d760b5d0f2e1a15ab6380b953c4055fd397c026c19a619e4005e54aa305861f1aeed3ce43a9ed8d0626dd992167b69b23b35a6820b172953b1b9b74c5ff2ca88c0bcc36b5d1dda0244ae78d399ba74ef169a8852d3b85b7a7c82ef5dad24c1f4d0a871b01954ddc579423a7f451fb30d5d0b66a823cb21b59e5017a664361be2d8c01f8acb6d6a548cdfca53cbd5b150574ed912e4b9a029401a66f12a5a799bb088c00f18c3bb17b041f3c722396fecf741eb05966c4b757c39eb5e00540148c87661ece9a61f36009540c860ccc00cf692081727d418b1756cb97897328ce63f0a1e4dd5d04d1a8868595cc6688407c7093ae2f83e91922223b6bde57a42c0de1b4d189c0360e97b62107273664126ba6685b65506528afedcfc3fec7e05e39eba37f5df7a18693e391a4fa95782c5bc1c45bd7292b3e5e7810dc5e3a884189de7101e1720b6e895f94c1b21456313e5edff68a1f6af7abda5e0fe685b4dca42a1f52aaa1cc734bd0892644514f009eba6a3d2a30bb6a5426fd8770707c7248c2feebcee638db65c7fa56e42d4434a877627c0eb66193c5a3065852f143d9a6d9add60481f7953086d1addaddae1ab818eae64fd12f5b57b92f56f093b5e38e066a56836eaace7586707e39428588fd731ec19269f73dab89c3d1458b64f74c81ffb1b1a1a008f3096a642304ca5534ceaa6d2e9b116221290e3a8dba23556c2d8caae2d743cffa63248fc946b3656b0a13eb79b92c2984f2f7f99a1234e559c484a9454330a89c1d771fe28a87ac4c9b44c5605016a6ce32648eadf3eb2a544ca9c5c5c162d6ee455ed14c39f78eb9ea29df2efc0e3c7d0457c8d72245cac867a0fe45c86167a380ad9e80505daa51d522b5413349c13bf5eaac178a58717e42c5f425e828237729ce71616df3eb920dad7d4a8bcdd93d159f903dfdded6e6dd8bde1f60c74e349701e5c075b2dd2d1a125ce81b3681c1fff3b3717cb6db681dda9e25fba1326889950311fc4de85c1ae8741f7f4cc144c88479d0f748e795df8dd9be1d1109de11ed71f78c66f4dbda5a4542fb96bdc856674fca5cc818792849eabe866c2dd943c482d917906c443f41610b06a08ca3233ec3ad146f204b1b4cfed77a07e0f83a0c8f4d735a2d923e6c8a6b3d859e3f5b0500c390cc3e01e5278e04992f6175cd1712f3097c811e08824a6f9ef02c5587a0f795630e7e0f23984fc127dbd31622d58cfeb1f32bb92a24849723158c8529bee89bbceebaf4a3da8d26b8718f40326894f0763a3e0454b3950c483ef5d614a6ca513daf3708de96608772e3aa8eb1576855249cb9e27be19d0910312592e74121ec3e69f0f8a2e7d2306ea9a6835c119abd7c751d80af9bc89ce978f44df6a945ef564d6d429294c502ee95ae09676f2fc27945792b3ee1020f7764e6e940e17d1a2191e1abd33b25a4d509f8d1eacda5ef2fd01d0f9aead585085ab9b736c535f8db3b30ca1dad11cf7d407d20c66ca07affa6abea54e959a496745bdd3666ea15d79d8992db42aaf7ed3d1c3da79c9c449b30359776909fb498c729e33da26fbd8504904000fd5085527db592ff1490479c1e31ff91c878fdbf620fff25b3927d7d6b63fd8649f13d5769d79841c8f628cc8dd03a6e455d607a92de53a4c5c585f63767d02a438d15b53e0d951dc7795391f18a2440adb8379efbd6a66f90c0a1d507864ed9950a1839b734e9b49e09d3719cce6eb8b292e98b26d06a8bf48bce0d7f5384b1d17db98655f061ed70dd0c57f84bf09483a1f1e8dfa455ba66e7e5be8c04e1b0cd4d56b6a6b4a3bc31a29eac1a893be3e81ddadac0e1f35bbdf23bd8c1379677006a9689ce94e1f440abb6f10bf2a719498450cb233081b2460c25d07e3b7df944f76faeac065bf8b6b48d679099a84ceca104099fa294fc77f4b579200e4fccd78cfb9941638843aa7c4c93bbc89b9c829dd3ad036de54a61278587e7ecc8367b48f863a00856fa32cac731d2fc2bcc66a65ebecb395e30dd76235f09a0fafd232d0604b9f959d15d12c743eabc9ec9f1c08c087af8c40d348a7b6913a83a3c43100519bed268596ec0c2f8b258c2bda0f14a93a57d7e9a78eeee8aaf2218a653cd2f752e2146d7601495931fe114592b3d693376240a46d09daad0f3ba84a8a9d05c079a3a7209f39e58c34b7f5209572f46443fd0580a829f875ffbc229ff77f1117d005df2e48d1926d35a2e971e75e574df37adfcff6a39dba57b8a347b9eef640d23ee2a7cab4e3fbefdb7fdcb9c766578783b8a37f5cac4e483b6a2b5b9f13118998a01de00e121ba11c3cbbb3360e9fe3d1332fead967ab9659a918b176ee89638328bb61564515af7f394aa4cdc4d48a7753eae869101ee98d6b9e14eda48bf8bff06b1b435fa6e8e286895037b8e8e75e79d5b91d07caeda4ca67a9b59f2431cdbc304b90bfb6c2b7281fc6ed87cf9884d56d0d0b85419349f0196c4f19f71d296901570c008ce1cd581d9762f121c94d9a0fafcb8f08f2332d87a46e6492bbfc07c8e5ccdd8d018d559933111f80470e590277f19c58cc833f559f1701eb674d5fb1df58585fb0b0a079758a676fd94994f16c7a0a35ccb78544bcd6dc387b085eeb9b4a2a648a8f0561439843b1306c539e2984825f064820c7123eec85ee803bfa42189db98901dddbe5d61f5a059a6cad3ee534147663b9884f020da2920be52c12af36e8cf8b86e7d0252b29e5de8e1e4a655df8dc3aeb3d3d18547a49fdbf826915831ed14a06361afd08fa4d83d3e6acbf8b364234cda843626dea79c490d30c3531b43884452b8e2bb70cda5ec9faf4fdd9e8bac8f7f961bf42f7d1df8904b0560da099d8b4510ca441be926223edc19ceb89769e8db3582b047be6ed8c6a826c3a1be672761b91bdd2e49ae4b538f6b08986caa8d8def9f02d109d8f79156679311fd0da2ecc02a9038d1511d5073c2469aa38f904c76d0d86b8385fad4494deeae798bd9fa4a2069c5c649f1655705de363bd7d6560014f6aa07e5ebaf54f145dbbde2c5d250d31fdef6415b899dc9db4e5fe1a0575db660249171e8ba0d7b96685aaf6e50269b33a4737f352c1a7b14f85d7862687b244713f58bc44c48d9a531257af1172c06eb988787c4cb3a1383689255050ad534dcd6225e68073c01c44e69bf8a82c7c392e62ea503f440be9d25e6d05d96aba52279b06faaae9bd4279ebe2bb123edb87e1b7fc512f46e5a7bb107b90d1dd00896ceeaf2f5648351e029554ec718c8883c53fc4a1c6b615dbbd8a84e84be47f6c517df2ffd9d13093f70e657924a6e6af333f688918e4b682978065c763ed45541981c88d05c82c06d02bc2a316d1d5f6c444271875c6bab45730517e27d325189d56136f45ecba4abd1aa095049831c9b924b8bb2d27cb7293ea2f16beca5432203cd509e6762ac43e8e4fa98fe86f13d61690fbd0758aec810ad067f0b3f69657bf3e5dc35729ed614230a6aac15691d73bee373d29f6a8fa90841c0a5c11f8447c689cb3230799fddd5f23651f1acd931e56c40a0a01880850b81159510eb2cadd390a2f7f1408c6031b06577599128caff07789ba87e36c6e40a59aceda86214c586158bd5c227497b2a4ddd1959149d788f6075a30b6917451d4225088a49fa9759a38146bf1ab4ac59e3a962444b74fb7f30c41200beb50a8f3d58bcfce8aa259f148c2fc49d7b0fdee9e59b7ad0e34dbf9346bf9caa29b617bbda3268bd92d848ab97498463c66032d6faa93aae1ed7cccda8a05d7c5207ec4c4c5274c4cb67a11564f30f2535c5338689ab311369c91e2176738a99bbbb12dac0a6e37033b716822276f72b43517afe35bdef68b19959e8d366e308c5f8e0b7a8b16f47c8c68125d67066acc24a67873ec2d11a6dc2a21203a7b048752059046772b5d8c00668e40b38c9378a63d3e7756fdfa7019122a4aecaeb004d361e8fb8a6a1d087e45d470cf3f14cd540cb379270988b15499cbb5a829f677ac0fc99ed715ba372a9f44711d69615d739a29e8f11b73b2dda8f65fd9d3d3f0651fbf0898d1ecae8417cb962fecb02db1c927420ef3d5840d296900bb785df78e544616c57f1e0a1128d55dbc43d2d42ace7bec048bde2550eeaeeba9359ea53069404b09e30549d77f70fd1d5084687b90de4a092f2f125c6f1b5b5c3683d44ad257311c39a2e769751fd25eb48d84550560a766e52a8d8e87e88f69b4f0f05aac5ea01d58b8a03f6faef31f3e6ae891ea1cf2abd74049ddf163574cbab480c1d92e496cd03c2661886f099972de876f965ec463616f6ca3f5d5e30c39fa3aafab49514967195a02196657f0563fc306d79b05f5693b66bff0795607a281a919cdeb2fc14ca16582f17a6540d353e8253cb192a64e08b959928401700317d7d0301b0010b3fec6fc78da99fb526dd488c2ac379033b245b894793f14214e78210a92909468750c29a0af94e500fa9149da771b2e464327c676ae805fbc748f982f429ef74644d6b4895b2575870867a41ca226ba3f0ed0e49666d30693f4299548c208479b12c7f490579a178bd0e090cafe38bfbb2544deede01f86d702322c994a06ea1f6077b2139cab9cb18eb483530128e571a44a646eb22aa188fc78f548bd5397b01339a95797fdcec87aa82d4ebbd66d696b9ad888b279b8dad4222c38ad0a3f5bec5b1878eaad7f79d1d3961e02002910d122263e06bc80d826a3b540c8f7240bf6a81420d2897515d66d0aed2f20b53cd4aadd2e7a99948f28a213257856b48aa75d6f6f184ec93c217340f6ed96eacb4b493fc7088406c0e54ecd27202ac0998ef7c768e","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e10b84816b9ca8113ba8ab3af52c02b1"};

    // you can edit these values to customize some of the behavior of StatiCrypt
    const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
    };

    // init the staticrypt engine
    const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

    // try to automatically decrypt on load if there is a saved password
    window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
            // hide loading screen
            document.getElementById("staticrypt_loading").classList.add("d-none");
            document.getElementById("staticrypt_content").classList.remove("d-none");
            document.getElementById("staticrypt-password").focus();

            // show the remember me checkbox
            if (isRememberEnabled) {
                document.getElementById("staticrypt-remember-label").classList.remove("d-none");
            }
        }
    };

    // toggle password visibility
    document.getElementById("staticrypt-btn-password-visibility")
    .addEventListener("click", function () {
        const passwordInput = document.getElementById("staticrypt-password");
        if (passwordInput.type === "password") {
            passwordInput.type = "text";
        } else {
            passwordInput.type = "password";
        }
    });

    // handle password form submission
    document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
        e.preventDefault();

        const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById("staticrypt-remember").checked;

        const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

        if (!isSuccessful) {
            alert(templateError);
        }
    });
</script>



</div>
    <script src="/assets/script.js"></script>
    <script src="/assets/bootstrap.bundle.min.js"></script>
  </body>
</html>

